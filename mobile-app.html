<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>CIT 317: Mobile App Development Quiz</title>
        <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }

        #quiz-container {
            background: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            margin: 30px auto;
        }

        h1, h2 {
            text-align: center;
            color: #5a4fcf; /* Purple color */
        }

        #question-area {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }

        #question-text {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
             /* Ensure long questions wrap */
             white-space: pre-wrap; /* Allows wrapping */
             word-wrap: break-word; /* Breaks long words if needed */
        }

        /* Styles for Multiple Choice */
        .option {
            display: block;
            margin-bottom: 12px;
            background-color: #e9e7f8; /* Light purple background */
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .option:hover {
             background-color: #dcd6f7; /* Slightly darker purple on hover */
        }
        .option input[type="radio"] {
            margin-right: 10px;
            display: none; /* Hide radio button visually */
        }
        .option label {
            cursor: pointer;
            display: block; /* Make label fill the option div */
            width: 100%;
        }
        .option.selected { /* Add class via JS on selection */
            background-color: #c1bbf0;
        }
        .option.correct {
            background-color: #a3d9a5 !important; /* Force green */
            border: 2px solid #155724;
            color: #155724;
        }
        .option.incorrect {
             background-color: #f0aaaa !important; /* Force red */
             border: 2px solid #721c24;
             color: #721c24;
        }
         .option.disabled { /* For non-selected, non-correct options after submit */
            cursor: not-allowed;
            opacity: 0.7;
            background-color: #f0f0f0;
        }

        /* Styles for Critical Thinking */
        #critical-thinking-answer {
             display: block;
             width: 95%; /* Slightly less than 100% for padding */
             min-height: 150px;
             margin-top: 15px;
             padding: 10px;
             border: 1px solid #ccc;
             border-radius: 5px;
             font-family: sans-serif;
             font-size: 1em;
             resize: vertical; /* Allow vertical resizing */
        }
         #critical-thinking-prompt {
            font-style: italic;
            color: #666;
            margin-top: 10px;
            font-size: 0.9em;
         }

        /* Buttons */
        #submit-btn, #next-btn, #restart-btn {
            display: block;
            width: auto;
            padding: 12px 25px;
            background-color: #5a4fcf; /* Purple button */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin: 20px auto 0; /* Center button */
            transition: background-color 0.3s ease;
        }
        #submit-btn:hover, #next-btn:hover, #restart-btn:hover {
            background-color: #413a9a; /* Darker purple on hover */
        }
        #submit-btn:disabled {
             background-color: #cccccc;
             cursor: not-allowed;
        }

        /* Feedback & Explanation Area */
        #feedback-area {
            margin-top: 15px;
            padding: 15px;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
        }
        .correct-feedback {
            background-color: #d4edda; /* Greenish */
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .incorrect-feedback {
            background-color: #f8d7da; /* Reddish */
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        #explanation-area {
            margin-top: 15px;
            padding: 15px;
            background-color: #f0f0f0; /* Light gray background */
            border: 1px solid #ccc;
            border-radius: 5px;
            line-height: 1.5;
            text-align: left; /* Ensure text is left-aligned */
             /* Keep formatting like newlines from the explanation string */
             white-space: pre-wrap;
             word-wrap: break-word;
        }
         #explanation-area h4 { /* Style for explanation heading */
            margin-top: 0;
            color: #413a9a;
            margin-bottom: 10px;
         }

        /* Score Area */
        #score-area {
            text-align: right;
            font-weight: bold;
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #413a9a;
        }

        /* Results Area */
        #results-area {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            background-color: #e9e7f8;
            border-radius: 8px;
        }
         #results-area h2 {
            color: #413a9a;
         }
         #results-info {
             font-size: 0.9em;
             color: #555;
             margin-top: 15px;
         }

        /* Hide elements initially */
        #next-btn, #feedback-area, #explanation-area, #results-area, #restart-btn, #critical-thinking-answer, #critical-thinking-prompt {
            display: none;
        }
    </style>
    </head>
    <body>

        <div id="quiz-container">
            <h1>CIT 317: Mobile App Development Quiz</h1>

            <div id="score-area">MC Score: <span id="score">0</span> / <span
                    id="total-mc-questions">0</span></div>

            <div id="question-area">
                <p id="question-text"></p>
                <div id="options-container">
                    <!-- MC Options will be loaded here by JS -->
                </div>
                <!-- Critical Thinking Input Area -->
                <p id="critical-thinking-prompt">Consider your response to the
                    question above. Type your thoughts here (this will not be
                    graded).</p>
                <textarea id="critical-thinking-answer"
                    placeholder="Type your critical analysis here..."></textarea>

                <button id="submit-btn">Submit Answer</button>
                <div id="feedback-area"></div> <!-- Feedback only for MC -->
                <div id="explanation-area"></div> <!-- Explanation Area -->
                <button id="next-btn">Next Question</button>
            </div>

            <div id="results-area">
                <h2>Quiz Completed!</h2>
                <p id="final-score"></p>
                <p id="results-info">This score reflects multiple-choice
                    questions only. Critical thinking questions were included
                    for reflection.</p>
                <button id="restart-btn">Restart Quiz</button>
            </div>
        </div>

        <script>
        const quizData = [
             // --- Start Combination ---
             // Chapter 1 - MCQs (2)
            {
                type: 'mc',
                question: "What is the primary difference between Native and Hybrid mobile apps?",
                options: [
                    "Native apps are built using web technologies (HTML, CSS, JS), while Hybrid apps use platform-specific languages (Swift, Kotlin).",
                    "Native apps run only on Android, Hybrid apps run only on iOS.",
                    "Native apps are built for specific OS (iOS/Android) using platform SDKs, offering optimal performance, while Hybrid apps use web tech inside a native wrapper, allowing cross-platform code.",
                    "Hybrid apps can access all device features, while Native apps have limited access."
                ],
                correctIndex: 2,
                explanation: "Native apps are developed specifically for one operating system (like iOS or Android) using its native programming language (Swift/Objective-C for iOS, Kotlin/Java for Android) and SDKs. This gives them the best performance and access to all device features.\nHybrid apps are essentially web apps (HTML, CSS, JS) packaged inside a native 'container'. Frameworks like React Native or Flutter allow developers to write code (often JavaScript or Dart) that gets translated or bridged to native components. They allow for code sharing across platforms but might have performance limitations or dependencies on plugins for accessing certain native features."
            }, // Comma after object
            {
                type: 'mc',
                question: "Which set of technologies is most commonly associated with Web Development, as opposed to native App Development?",
                options: [
                    "Java, Kotlin, Swift",
                    "HTML, CSS, JavaScript, Angular/React",
                    "Flutter, React Native, Ionic",
                    "C#, Objective-C"
                ],
                correctIndex: 1,
                explanation: "HTML (structure), CSS (styling), and JavaScript (interactivity) are the core technologies of the web. Frameworks like Angular and React are widely used for building complex web applications.\nJava/Kotlin (Android) and Swift (iOS) are primary native app languages. Flutter, React Native, and Ionic are cross-platform *mobile* app frameworks (though React can also be used for web). C# is used for native development (Xamarin/MAUI) and Objective-C was the predecessor to Swift for iOS."
            }, // Comma after object
             // Chapter 1 - Critical (1)
            {
                type: 'critical',
                question: "Scenario: A small news organization wants to deliver breaking news alerts and read articles offline. Limited budget, web-skilled team, needs iOS & Android presence quickly. Critically evaluate Native, Hybrid, and Web apps. Justify your recommendation and explain the key trade-offs (performance, cost, features, time-to-market).",
                explanation: `#### Answer Guidance:\n*   **Web App:** Lowest cost/fastest start with existing web skills. However, implementing robust offline storage and native push notifications is difficult or limited compared to other approaches. Poor user experience for app-like features.\n*   **Native Apps:** Offers the best performance, smoothest UI, and easiest access to all native features (push, offline storage). BUT, it requires separate codebases (iOS/Android), specialized skills (Swift/Kotlin), doubling development time and cost – unsuitable for the limited budget and quick launch requirement.\n*   **Hybrid Apps:** The most likely recommendation. Frameworks like React Native or Flutter allow leveraging existing web-like concepts (component-based UI) or even direct web skills (Ionic). They enable significant code sharing, reducing time and cost. Access to native features like push notifications and offline storage (SQLite, local file storage) is available through plugins/modules. While performance might be slightly less than pure native, it's generally sufficient for content-based apps like a news reader.\n*   **Trade-offs of Hybrid:** Slightly lower peak performance than native, reliance on framework updates and plugin availability/quality, potentially larger app size.\n*   **Justification:** Hybrid balances the constraints: uses related skills, faster time-to-market than native, lower cost than native, provides necessary feature access (push, offline), and reaches both platforms.`
            }, // Comma after object
            // Chapter 2 - MCQs (2)
            {
                 type: 'mc',
                question: "Which factor is LEAST critical when choosing between iOS and Android development platforms initially?",
                options: [
                    "Target audience demographics and geography",
                    "Required app features and hardware access (e.g., specific AR capabilities)",
                    "Development budget and team's existing skills",
                    "The specific color theme options available in the default SDK"
                ],
                correctIndex: 3,
                explanation: "While UI/UX is important, the specific default color themes are easily customizable and not a fundamental platform constraint. Target audience (iOS users often spend more, Android has larger global share), required features (e.g., Apple's ARKit might be superior for certain AR), and budget/skills (iOS often requires Macs, specific languages) are much more critical strategic factors influencing the platform choice."
            }, // Comma after object
             {
                 type: 'mc',
                question: "What is the first stage in the typical Mobile Application Development Lifecycle?",
                options: [
                    "Development (Coding)",
                    "Testing",
                    "Deployment",
                    "Research/Planning"
                ],
                correctIndex: 3,
                explanation: "The lifecycle typically begins with Research/Planning. This involves defining the app's purpose, target audience, core features, platform choice, monetization strategy, competitive analysis, and initial technical feasibility assessment. Skipping this stage leads to poorly defined projects, scope creep, budget overruns, and potential failure."
            }, // Comma after object
            // Chapter 2 - Critical (1)
             {
                type: 'critical',
                question: "Argue why skipping or significantly rushing the 'Research/Planning' stage often leads to greater costs and delays later in the lifecycle. Provide specific examples of problems that might arise during Development or Testing due to inadequate planning.",
                explanation: `#### Answer Guidance:\nSkipping/rushing planning introduces significant risks that manifest later:\n*   **Increased Rework:** Without clear requirements and design, developers might build the wrong features or implement them incorrectly, requiring costly changes during or after development (e.g., changing core navigation after user testing reveals confusion).\n*   **Technical Debt:** Poor initial architectural decisions made in haste can lead to code that's hard to maintain, test, and extend, slowing down future development.\n*   **Budget/Timeline Overruns:** Discovering technical challenges (e.g., an API is unreliable, a required feature needs a complex custom solution) or major usability issues late in the process leads to unexpected delays and costs.\n*   **Wrong Target/Platform:** Realizing during testing that the chosen platform doesn't adequately support a key feature, or that the target audience prefers a different platform, can necessitate a major pivot or project failure.\n*   **Examples:**\n    *   **Development:** Constant back-and-forth on feature details because they weren't defined; discovering a chosen third-party library has critical bugs or limitations.\n    *   **Testing:** Finding fundamental usability flaws requiring significant UI redesign; realizing performance is unacceptable on target devices due to poor architectural choices.`
            }, // Comma after object
            // Chapter 3 - MCQs (3)
            {
                type: 'mc',
                question: "In the Model-View-Controller (MVC) pattern, what is the primary responsibility of the 'Model' component?",
                options: [
                    "Displaying the user interface and visual elements.",
                    "Handling user input and interactions.",
                    "Managing the application's data, logic, and rules (interacting with database/APIs).",
                    "Controlling the flow between the View and the data source directly."
                ],
                correctIndex: 2,
                explanation: "The Model is responsible for the application's data and business logic. It encapsulates the data (e.g., user profile, product list) and the rules for manipulating it (e.g., validation, calculations). It interacts with data sources like databases or APIs and provides data to the Controller when requested. The View displays the data, and the Controller acts as the intermediary, handling user input and updating the Model or View."
            }, // Comma after object
            {
                 type: 'mc',
                 question: "Which data storage option in Android is best suited for storing small amounts of simple key-value data, like user preferences?",
                 options: [
                    "SQLite Database",
                    "File Storage (Internal/External)",
                    "Shared Preferences",
                    "Content Providers"
                 ],
                 correctIndex: 2,
                 explanation: "Shared Preferences are designed specifically for storing small collections of key-value pairs, typically primitive data types (booleans, strings, ints, etc.). This makes them ideal for user settings or flags.\nSQLite is for structured, relational data (like tables in a database). File storage is for raw files (images, documents). Content Providers are for sharing data between applications."
            }, // Comma after object
            {
                type: 'mc',
                question: "What does API stand for in the context of software development?",
                options: [
                    "Application Programming Interface",
                    "Applied Programming Interaction",
                    "Automated Processing Instruction",
                    "Application Process Integration"
                ],
                correctIndex: 0,
                explanation: "API stands for Application Programming Interface. It defines a set of rules, protocols, and tools for building software applications. An API specifies how software components should interact, allowing different systems or parts of a system to communicate with each other without needing to know the internal details of how they are implemented."
            }, // Comma after object
             // Chapter 3 - Critical 1 (Storage Security) (1)
             {
                type: 'critical',
                question: "Compare using SharedPreferences/UserDefaults versus EncryptedSharedPreferences/Keychain for storing user authentication tokens locally. Why is using the standard (non-encrypted) approach a significant security risk, especially on rooted/jailbroken devices?",
                explanation: `#### Answer Guidance:\n*   **Standard (SharedPreferences/UserDefaults):** Stores data as simple key-value pairs in an XML (Android) or plist (iOS) file within the app's private directory. This data is stored in **plaintext** or easily reversible encoding.\n*   **Secure (EncryptedSharedPreferences/Keychain):**\n    *   \`EncryptedSharedPreferences\` (Android): A library that automatically encrypts keys and values before storing them in standard SharedPreferences, using cryptographic best practices.\n    *   \`Keychain\` (iOS): A system-level secure database specifically designed for storing small pieces of sensitive data like passwords, keys, and tokens. Data is strongly encrypted and can be protected by device passcode/biometrics. Access controls can limit when and how the data can be retrieved.\n*   **Security Risk:** Authentication tokens grant access to a user's account. Storing them in plaintext via standard SharedPreferences/UserDefaults makes them vulnerable. On a rooted (Android) or jailbroken (iOS) device, the security sandboxing is compromised. Malicious apps or users with root privileges can potentially access the app's private directory and read these plaintext files, stealing the token and hijacking the user's session.\n*   **Conclusion:** Secure storage mechanisms are essential for sensitive data like auth tokens because they add a strong layer of encryption, making data significantly harder to steal even if the device's basic file system security is bypassed.`
             }, // Comma after object
             // Chapter 3 - MCQs (2)
            {
                type: 'mc',
                question: "Which of the following is a major security concern related to 'Insecure Data Storage' in mobile apps?",
                options: [
                    "Using strong encryption for all network communication.",
                    "Storing sensitive information like passwords or private keys in plaintext within the app's local storage.",
                    "Implementing robust user authentication.",
                    "Regularly updating third-party libraries."
                 ],
                 correctIndex: 1,
                 explanation: "Insecure Data Storage refers specifically to risks associated with how data is saved *locally* on the device. Storing sensitive data (passwords, API keys, personal info, tokens) without adequate encryption (i.e., in plaintext or weak encoding) in places like SharedPreferences, SQLite databases, or plain files is a major vulnerability. If the device is compromised (lost, stolen, rooted/jailbroken), this data can be easily extracted."
            }, // Comma after object
              {
                type: 'mc',
                question: "What is the purpose of 'Code Signing' a mobile application?",
                options: [
                    "To compress the application code for smaller download size.",
                    "To verify the author/developer of the app and ensure the code hasn't been tampered with since signing.",
                    "To automatically translate the app into different languages.",
                    "To enable push notifications."
                 ],
                 correctIndex: 1,
                 explanation: "Code signing uses a digital certificate (linked to the developer) to create a cryptographic signature for the application package. This signature serves two main purposes: \n1. **Authenticity:** It verifies that the app genuinely comes from the developer who holds the corresponding private key. \n2. **Integrity:** It ensures that the app's code has not been altered or corrupted since it was signed by the developer. Operating systems like Android and iOS check this signature during installation and updates."
            }, // Comma after object
            // Chapter 3 - Critical 2 (MVC) (1)
             {
                type: 'critical',
                question: "How does strictly adhering to MVC help manage complexity and facilitate collaboration when building a large-scale mobile application with multiple developers? Contrast this with mixing UI logic, data handling, and user input in the same code files.",
                explanation: `#### Answer Guidance:\n*   **MVC Benefits for Large Apps/Teams:**\n    *   **Separation of Concerns:** Dividing the app into Model (data/logic), View (UI), and Controller (mediator) makes the codebase easier to understand and navigate.\n    *   **Modularity & Collaboration:** Developers can specialize and work on different layers concurrently with less conflict. A UI developer can work on the View while a backend/logic developer works on the Model, interacting primarily through the Controller interface.\n    *   **Testability:** Each component can be tested more independently. Models can often be unit-tested without UI. Views can be tested visually or with UI testing frameworks. Controllers can be tested for their logic.\n    *   **Maintainability:** Changes in one layer have less impact on others. Fixing a UI bug is less likely to break data logic. It's easier to find where specific functionality resides.\n*   **Contrast with Mixed Logic (e.g., Massive ViewController/Activity):**\n    *   **High Coupling:** Code becomes tightly interwoven ("spaghetti code"). Changing a UI element might require significant changes in data fetching or business logic within the same file.\n    *   **Difficult Collaboration:** Multiple developers editing the same large file increases merge conflicts and the risk of breaking each other's work.\n    *   **Poor Testability:** Unit testing becomes very difficult as logic is tied to UI components and lifecycle events.\n    *   **Hard to Maintain/Understand:** The codebase becomes brittle, complex, and difficult for new team members to grasp or for anyone to debug effectively.`
             }, // Comma after object
             // Chapter 4 - MCQs (3)
             {
                 type: 'mc',
                question: "Which tool is the official Integrated Development Environment (IDE) for Android development provided by Google?",
                options: [
                    "Xcode",
                    "Visual Studio Code",
                    "Android Studio",
                    "Eclipse with ADT Plugin"
                ],
                correctIndex: 2,
                explanation: "Android Studio is the official IDE specifically designed for Android app development. It's built on IntelliJ IDEA and provides tools for coding, debugging, testing, and packaging Android apps. Xcode is Apple's IDE for iOS/macOS. Visual Studio Code is a general-purpose code editor. Eclipse with the ADT plugin was the predecessor to Android Studio but is no longer officially supported."
            }, // Comma after object
            {
                type: 'mc',
                question: "In Android development, what are Layouts primarily used for?",
                options: [
                    "Defining the app's data structure.",
                    "Handling network requests.",
                    "Defining the visual structure and arrangement of UI elements on the screen.",
                    "Storing user preferences."
                ],
                correctIndex: 2,
                explanation: "Layouts (like LinearLayout, RelativeLayout, ConstraintLayout, FrameLayout) are containers used in Android to define how UI elements (Views like Buttons, TextViews, ImageViews) are positioned and organized on the screen. They dictate the visual hierarchy and arrangement."
            }, // Comma after object
             {
                type: 'mc',
                question: "Which technology is commonly used for backend services, real-time databases, and push notifications in Android apps, provided by Google?",
                options: [
                    "SQLite",
                    "Realm",
                    "Firebase",
                    "Shared Preferences"
                 ],
                 correctIndex: 2,
                 explanation: "Firebase is Google's mobile and web application development platform. It offers a suite of backend services, including Firestore (NoSQL cloud database), Realtime Database, Cloud Functions (serverless computing), Authentication, Cloud Messaging (for push notifications), Crashlytics, and more. SQLite and Realm are local database solutions. Shared Preferences are for simple key-value storage."
             }, // Comma after object
            // Chapter 4 - Critical (RecyclerView) (1)
            {
                 type: 'critical',
                 question: "An Android app displaying a long, scrollable list of network images using LinearLayout inside ScrollView becomes slow and crashes with OutOfMemoryError. Explain why this is inefficient. Recommend a better UI component and explain how it solves these issues.",
                 explanation: `#### Answer Guidance:\n*   **Inefficiency Explained:** Using \`LinearLayout\` inside a \`ScrollView\` forces the system to create and keep in memory **all** the Views for **every single item** in the list, even those currently off-screen. For a long list, especially with memory-intensive items like images, this consumes a huge amount of RAM, leading to \`OutOfMemoryError\` crashes. It also makes scrolling inefficient because the system has to measure and draw a potentially massive layout.\n*   **Recommendation:** \`RecyclerView\`.\n*   **How RecyclerView Solves It:**\n    *   **View Recycling:** \`RecyclerView\` only creates enough ViewHolders (containers for item views) to fill the screen plus a small buffer. As items scroll off-screen, their views are not destroyed but put into a pool to be **reused** (recycled) for new items scrolling onto the screen. This drastically reduces memory consumption and the overhead of creating new views.\n    *   **ViewHolder Pattern:** Enforces the use of the ViewHolder pattern, which avoids repeated calls to \`findViewById()\` (an expensive operation) by storing references to the item's subviews within the ViewHolder object.\n    *   **LayoutManager:** Separates the policy of *how* items are laid out (linear, grid, staggered) from the recycling mechanism, providing flexibility.`
            }, // Comma after object
             // Chapter 5 - MCQs (2)
             {
                 type: 'mc',
                question: "What type of testing involves testing individual, small, isolated parts (like functions or methods) of an application's code?",
                options: [
                    "Integration Testing",
                    "Unit Testing",
                    "Beta Testing",
                    "User Acceptance Testing (UAT)"
                ],
                correctIndex: 1,
                explanation: "Unit Testing focuses on testing the smallest testable parts of an application, typically individual functions or methods, in isolation from the rest of the system. The goal is to verify that each 'unit' of code works correctly on its own. Dependencies are often mocked or stubbed out.\nIntegration testing checks if different units/modules work together. Beta testing involves real users. UAT confirms the system meets user requirements."
            }, // Comma after object
            {
                type: 'mc',
                question: "What is the primary purpose of 'Crash Reporting Tools' like Firebase Crashlytics?",
                options: [
                    "To automate UI testing.",
                    "To measure app performance bottlenecks.",
                    "To automatically collect, analyze, and report details about application crashes occurring on users' devices.",
                    "To manage user feedback and feature requests."
                ],
                correctIndex: 2,
                explanation: "Crash Reporting tools (like Firebase Crashlytics, Sentry, Bugsnag) automatically capture detailed information (stack traces, device state, OS version, app version) when an application crashes on an end-user's device. This data is sent to a dashboard, allowing developers to prioritize, diagnose, and fix crashes efficiently, improving app stability."
            }, // Comma after object
             // Chapter 5 - Critical (Beta Testing) (1)
            {
                type: 'critical',
                question: "A mobile game team conducts thorough Unit and Alpha testing. Argue why Beta Testing with real users is still crucial for this game's success. What specific types of feedback or issues are more likely uncovered during Beta Testing?",
                explanation: `#### Answer Guidance:\nEven with rigorous internal testing, Beta testing is crucial because:\n*   **Real-World Environment:** It exposes the game to a wide variety of real devices, OS versions, network conditions (slow/flaky Wi-Fi, cellular data), and usage patterns that are impossible to fully simulate internally.\n*   **Unbiased User Perspective:** Real users provide fresh eyes and unbiased feedback on gameplay, fun factor, difficulty, controls, and intuitiveness. Internal testers might be too familiar with the game or hesitant to give harsh feedback.\n*   **Discovering Edge Cases:** The sheer number and diversity of beta testers increase the chance of uncovering rare bugs, device-specific issues, or unexpected interactions missed during Alpha testing.\n*   **Feedback More Likely Uncovered in Beta:**\n    *   **Performance Issues:** Lag, battery drain, overheating on specific (often lower-end) devices not in the internal test pool.\n    *   **Usability/Fun Factor:** Confusion about game mechanics, unfair difficulty spikes, boring sections, awkward controls.\n    *   **Network Robustness:** Issues related to poor connectivity, synchronization problems in multiplayer.\n    *   **Device Compatibility:** Crashes or visual glitches specific to certain manufacturers or OS versions.\n    *   **Scalability (if backend involved):** Issues under concurrent user load.`
            }, // Comma after object
            // Chapter 6 - MCQs (2)
             {
                type: 'mc',
                question: "Which testing phase involves releasing the app to a limited group of external users (real users) in a real-world environment before the final public release?",
                options: [
                    "Unit Testing",
                    "Alpha Testing",
                    "Beta Testing",
                    "Regression Testing"
                ],
                correctIndex: 2,
                explanation: "Beta Testing is the phase where a nearly finished version of the application is released to a select group of external users (beta testers) outside the development organization. The goal is to get feedback on usability, performance, and bugs in a real-world setting before the official launch. Alpha testing is typically internal testing by QA or other employees."
            }, // Comma after object
            {
                 type: 'mc',
                question: "What is an Android App Bundle (.aab)?",
                options: [
                    "A single, universal APK file that works on all devices.",
                    "A development format containing only the app's source code.",
                    "A publishing format that includes all compiled code and resources, allowing Google Play to generate optimized APKs for specific devices.",
                    "A file containing only the app's graphic assets."
                ],
                correctIndex: 2,
                explanation: "An Android App Bundle (.aab) is a publishing format uploaded to Google Play. It contains all the app's compiled code and resources for all supported device configurations (different architectures, screen densities, languages). Google Play then uses the App Bundle to generate and serve optimized APKs tailored to each user's specific device, resulting in smaller download sizes for users compared to monolithic APKs."
            }, // Comma after object
             // Chapter 6 - Critical (Guidelines) (1)
            {
                type: 'critical',
                question: "An app update gets rejected for requesting excessive permissions. Explain the importance of app store guidelines regarding user privacy/permissions. What are potential negative consequences for the developer (beyond rejection) if they repeatedly try to circumvent these guidelines?",
                explanation: `#### Answer Guidance:\n*   **Importance of Guidelines:** App store guidelines regarding permissions are crucial for:\n    *   **User Privacy & Trust:** Protecting users from apps that collect unnecessary data or perform actions without justification. This builds trust in the platform ecosystem.\n    *   **Security:** Limiting an app's capabilities reduces the potential damage if the app itself is malicious or compromised.\n    *   **Transparency:** Forcing developers to justify permission requests helps users understand why access is needed.\n*   **Potential Negative Consequences for Developer:**\n    *   **Repeated Rejections/Delays:** Wastes significant time and resources, delaying bug fixes and feature releases.\n    *   **Negative User Perception:** If users notice excessive permission requests (even if approved), it can lead to negative reviews, uninstalls, and damage to the app's reputation.\n    *   **Reduced Discoverability:** Stores might penalize apps with poor user reviews or trust signals.\n    *   **App Suspension:** Persistent or egregious violations can lead to the app being permanently removed from the store.\n    *   **Developer Account Termination:** In severe cases, the developer's entire account could be terminated, preventing them from publishing any apps on that platform.`
            }, // Comma after object
            // Chapter 7 - MCQs (4)
             {
                 type: 'mc',
                question: "Why are App Store Guidelines (like those from Apple App Store or Google Play Store) important for developers?",
                options: [
                    "They are optional recommendations with no real impact.",
                    "They primarily focus on suggesting monetization strategies.",
                    "They define rules for security, privacy, performance, content, and business practices that apps must follow to be accepted and remain on the store.",
                    "They only apply to hybrid applications, not native ones."
                 ],
                 correctIndex: 2,
                 explanation: "App Store Guidelines are mandatory rules set by platform owners (Apple, Google) that developers must adhere to for their apps to be listed and remain available. They cover a wide range of aspects including safety, security, privacy, performance, design, content appropriateness, and business models. Failure to comply can lead to rejection during review or removal from the store."
            }, // Comma after object
            {
                 type: 'mc',
                question: "What is the primary IDE used for developing native iOS applications?",
                options: [
                    "Android Studio",
                    "Xcode",
                    "Visual Studio",
                    "NetBeans"
                ],
                correctIndex: 1,
                explanation: "Xcode is Apple's official Integrated Development Environment (IDE) for developing software for macOS, iOS, iPadOS, watchOS, and tvOS. It includes a source code editor, graphical interface builder, debugging tools, simulators, and compilers for Swift and Objective-C. Android Studio is for Android, Visual Studio is primarily for Windows/.NET (though it has mobile extensions), and NetBeans is a general Java IDE."
            }, // Comma after object
            {
                 type: 'mc',
                question: "Which programming language was introduced by Apple as a modern, safe, and powerful language for iOS, macOS, watchOS, and tvOS development?",
                options: [
                    "Java",
                    "Kotlin",
                    "C#",
                    "Swift"
                ],
                correctIndex: 3,
                explanation: "Swift was introduced by Apple in 2014 as a successor to Objective-C. It was designed to be safer, faster, and more modern, incorporating features like type inference, optionals, robust error handling, and value types to help developers write more reliable code for Apple platforms. Kotlin is primarily used for Android, Java historically for Android, and C# for various platforms including mobile via Xamarin/MAUI."
            }, // Comma after object
            {
                type: 'mc',
                question: "What tool within Xcode allows developers to test their iOS apps on simulated iPhone or iPad environments without needing a physical device?",
                options: [
                    "Instruments",
                    "Interface Builder",
                    "iOS Simulator",
                    "Swift Package Manager"
                ],
                correctIndex: 2,
                explanation: "The iOS Simulator, included with Xcode, provides a way to run and test iOS, iPadOS, watchOS, and tvOS apps on a Mac. It simulates various device types, screen sizes, and OS versions, allowing developers to quickly test functionality and UI without needing every physical device. Instruments is for performance profiling, Interface Builder for UI design, and Swift Package Manager for managing dependencies."
            }, // Comma after object
            // Chapter 7 - Critical (Swift Safety) (1)
             {
                type: 'critical',
                question: "Swift was designed with 'safety' as a key goal. Describe two specific Swift language features that contribute to safer code compared to Objective-C, and explain *how* these features help prevent common runtime crashes or bugs.",
                explanation: `#### Answer Guidance:\nChoose two examples like these:\n1.  **Optionals (\`?\`, \`!\`):**\n    *   **Feature:** Swift explicitly requires developers to handle cases where a variable might not have a value (\`nil\`). Variables must be declared as Optional (e.g., \`String?\`) if they can be \`nil\`.\n    *   **How it Helps:** This prevents unexpected crashes caused by attempting to access methods or properties on a \`nil\` reference (equivalent to null pointer exceptions). Developers are forced to safely unwrap optionals (using \`if let\`, \`guard let\`, optional chaining \`?.\`, or the nil-coalescing operator \`??\`) before using their value, making \`nil\`-related errors compile-time checks rather than runtime crashes.\n\n2.  **Strong Type System & Type Inference:**\n    *   **Feature:** Swift is strongly typed, meaning every variable has a specific type, and the compiler checks for type mismatches. It also has powerful type inference, reducing the need for explicit type declarations while maintaining safety.\n    *   **How it Helps:** Catches many errors at compile time that might only appear at runtime in more dynamically typed languages (like passing a number where a string is expected). This prevents type-related crashes and unexpected behavior, making the code more predictable and robust.\n\n*(Other valid examples include: Immutability by default (\`let\`), Value types (structs/enums) reducing side effects, Clear error handling (\`do-try-catch\`), Guard statements for early exits)*`
             } // NO comma after the last object in the array
             // --- End Combination (Total 20 MCQs, 8 Critical) ---
        ]; // Semicolon terminates the array assignment statement

        // DOM Elements
        const questionTextElement = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const criticalAnswerArea = document.getElementById('critical-thinking-answer');
        const criticalPrompt = document.getElementById('critical-thinking-prompt');
        const submitButton = document.getElementById('submit-btn');
        const feedbackArea = document.getElementById('feedback-area');
        const explanationArea = document.getElementById('explanation-area'); // Get explanation area
        const nextButton = document.getElementById('next-btn');
        const scoreElement = document.getElementById('score');
        const totalMcQuestionsElement = document.getElementById('total-mc-questions');
        const questionArea = document.getElementById('question-area');
        const resultsArea = document.getElementById('results-area');
        const finalScoreElement = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-btn');
        const resultsInfoElement = document.getElementById('results-info');


        // State Variables
        let currentQuestionIndex = 0;
        let score = 0;
        let selectedOptionElement = null; // To track the div of the selected option
        const totalMcQuestions = quizData.filter(q => q.type === 'mc').length; // Calculate total MC questions

        function loadQuestion() {
            // Reset common elements
            feedbackArea.style.display = 'none';
            feedbackArea.textContent = '';
            feedbackArea.className = 'feedback-area';
            explanationArea.style.display = 'none'; // Hide explanation on new question load
            explanationArea.innerHTML = ''; // Clear explanation
            optionsContainer.innerHTML = '';
            optionsContainer.style.display = 'none'; // Hide by default
            criticalAnswerArea.style.display = 'none'; // Hide by default
            criticalPrompt.style.display = 'none'; // Hide by default
            criticalAnswerArea.value = ''; // Clear textarea
            submitButton.style.display = 'none'; // Hide by default
            nextButton.style.display = 'none'; // Hide by default
            submitButton.disabled = true;
            selectedOptionElement = null;
            delete nextButton.dataset.explanationShown; // Reset explanation flag

            if (currentQuestionIndex < quizData.length) {
                const currentQuestion = quizData[currentQuestionIndex];
                // Use textContent to prevent potential HTML injection in question text
                questionTextElement.textContent = `${currentQuestionIndex + 1}. ${currentQuestion.question}`;

                // --- Display based on type ---
                if (currentQuestion.type === 'mc') {
                    optionsContainer.style.display = 'block';
                    submitButton.style.display = 'block'; // Show Submit only for MC

                    currentQuestion.options.forEach((option, index) => {
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'option';

                        const radioInput = document.createElement('input');
                        radioInput.type = 'radio';
                        radioInput.name = 'option';
                        radioInput.value = index;
                        radioInput.id = `option${index}`;
                        radioInput.addEventListener('change', () => {
                            submitButton.disabled = false;
                             if(selectedOptionElement) {
                                selectedOptionElement.classList.remove('selected');
                             }
                             selectedOptionElement = optionDiv;
                             selectedOptionElement.classList.add('selected');
                        });

                        const label = document.createElement('label');
                        label.htmlFor = `option${index}`;
                        // Use textContent for options as well
                        label.textContent = option;

                        optionDiv.appendChild(radioInput);
                        optionDiv.appendChild(label);
                        optionDiv.addEventListener('click', () => {
                            if (!radioInput.disabled) {
                                 radioInput.checked = true;
                                 radioInput.dispatchEvent(new Event('change'));
                            }
                        });
                        optionsContainer.appendChild(optionDiv);
                    });
                } else if (currentQuestion.type === 'critical') {
                     criticalAnswerArea.style.display = 'block';
                     criticalPrompt.style.display = 'block';
                     nextButton.style.display = 'block'; // Show Next directly for critical
                     nextButton.textContent = 'Proceed / Show Guidance'; // Initial text for critical
                }

                // Update score display
                totalMcQuestionsElement.textContent = totalMcQuestions;
                scoreElement.textContent = score;

                 // Set initial 'Next' button text if it's the last question
                 if (currentQuestionIndex === quizData.length - 1) {
                     // Will be updated later if MC, but set default for critical
                     if(quizData[currentQuestionIndex].type === 'critical') {
                        nextButton.textContent = 'Show Guidance / Results';
                     }
                     // For MC, it will be updated in submitAnswer
                 }

            } else {
                 showResults();
            }
        }

        function submitAnswer() { // Only called for MC questions
            const selectedRadio = optionsContainer.querySelector('input[name="option"]:checked');
            if (!selectedRadio) return; // Should be handled by button disable

            submitButton.disabled = true;
            submitButton.style.display = 'none';
            nextButton.style.display = 'block'; // Show next/results button

            const currentQuestion = quizData[currentQuestionIndex];
            const selectedAnswerIndex = parseInt(selectedRadio.value);
            const correctAnswerIndex = currentQuestion.correctIndex;

            const allOptionDivs = optionsContainer.querySelectorAll('.option');
            allOptionDivs.forEach((div, index) => {
                const radio = div.querySelector('input[type="radio"]');
                radio.disabled = true;
                div.classList.remove('selected');
                div.classList.add('disabled');

                if (index === correctAnswerIndex) {
                    div.classList.add('correct');
                    div.classList.remove('disabled');
                } else if (index === selectedAnswerIndex) {
                    div.classList.add('incorrect');
                    div.classList.remove('disabled');
                }
             });

            if (selectedAnswerIndex === correctAnswerIndex) {
                score++;
                feedbackArea.textContent = 'Correct!';
                feedbackArea.className = 'feedback-area correct-feedback';
            } else {
                // Use textContent for security/consistency
                feedbackArea.textContent = `Incorrect. The correct answer was: ${currentQuestion.options[correctAnswerIndex]}`;
                feedbackArea.className = 'feedback-area incorrect-feedback';
            }

            feedbackArea.style.display = 'block';
            scoreElement.textContent = score; // Update score display after checking

            // Display Explanation for MC Question
            if (currentQuestion.explanation) {
                // Use innerHTML here if explanations contain basic formatting like <h4> or \n converted to <br>
                explanationArea.innerHTML = `<h4>Explanation:</h4>${currentQuestion.explanation.replace(/\n/g, '<br>')}`; // Replace newlines with <br> for HTML display
                explanationArea.style.display = 'block';
            }

             // Set button text for the next step
             if (currentQuestionIndex === quizData.length - 1) {
                 nextButton.textContent = 'Show Results';
             } else {
                  nextButton.textContent = 'Next Question';
             }
        }

        function nextQuestion() {
            const currentQuestion = quizData[currentQuestionIndex]; // Get current question *before* potentially incrementing index

             // Logic for Critical Thinking questions: Show explanation on first click, proceed on second
            if (currentQuestion.type === 'critical') {
                 // Check if explanation is already shown using the data attribute flag
                 if (!nextButton.dataset.explanationShown) {
                    // First click: Show explanation
                    if (currentQuestion.explanation) {
                        explanationArea.innerHTML = `<h4>Guidance / Key Points:</h4>${currentQuestion.explanation.replace(/\n/g, '<br>')}`;
                        explanationArea.style.display = 'block';
                    }
                    nextButton.dataset.explanationShown = 'true'; // Mark explanation as shown
                    // Update button text to indicate the next action
                    if (currentQuestionIndex === quizData.length - 1) {
                        nextButton.textContent = 'Show Results';
                    } else {
                        nextButton.textContent = 'Next Question';
                    }
                    return; // Wait for the second click to proceed
                 }
                 // Second click (explanation was shown): Fall through to increment/show results logic
                  delete nextButton.dataset.explanationShown; // Reset flag for next time
            }

            // Proceed to next question or show results
            if (currentQuestionIndex >= quizData.length - 1) {
                 showResults();
            } else {
                 currentQuestionIndex++;
                 loadQuestion(); // Load next question
            }
        }


         function showResults() {
            questionArea.style.display = 'none';
            scoreArea.style.display = 'none';
            resultsArea.style.display = 'block';
            restartButton.style.display = 'block';

             // Calculate percentage based only on MC questions
             const percentage = totalMcQuestions > 0 ? ((score / totalMcQuestions) * 100).toFixed(1) : 0;
             finalScoreElement.textContent = `Multiple Choice Score: ${score} out of ${totalMcQuestions} (${percentage}%)`;
             resultsInfoElement.style.display = 'block'; // Ensure info text is shown
        }

        function restartQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            resultsArea.style.display = 'none';
            restartButton.style.display = 'none';
            questionArea.style.display = 'block';
            scoreArea.style.display = 'block';
            delete nextButton.dataset.explanationShown; // Reset flag if restarting
            loadQuestion();
        }


        // Event Listeners
        submitButton.addEventListener('click', submitAnswer); // Only enabled/shown for MC
        nextButton.addEventListener('click', nextQuestion); // Handles MC next, Critical proceed/explanation show, and Results show
        restartButton.addEventListener('click', restartQuiz);

        // Initial Load
        loadQuestion();

    </script>

    </body>
</html>
